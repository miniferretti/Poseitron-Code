
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module robot(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	PI,
	PI_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	BRIDGE,
	BRIDGE_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		PI;
input 		     [1:0]		PI_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		BRIDGE;
input 		     [1:0]		BRIDGE_IN;

        // F - front | R - rear
        // L - left  | R - Right
        logic quadA_FL, quadB_FL, quadA_RL, quadB_RL, quadA_FR, quadB_FR, quadA_RR, quadB_RR;
        assign quadA_FL = BRIDGE[26];
        assign quadB_FL = BRIDGE[27];
        assign quadA_RL = BRIDGE[30];
        assign quadB_RL = BRIDGE[31];
        assign quadA_FR = BRIDGE[28];
        assign quadB_FR = BRIDGE[29];
        assign quadA_RR = BRIDGE[32];
        assign quadB_RR = BRIDGE[33];


        // Clocks
        logic PLL_CLOCK;
        my_pll pll_clock(CLOCK_50, PLL_CLOCK);


        logic [31:0] count_FL, count_RL, count_FR, count_RR;
        quad encoder_FL(CLOCK_50, 1'b0, quadA_FL, quadB_FL, count_FL);
        quad encoder_RL(CLOCK_50, 1'b0, quadA_RL, quadB_RL, count_RL);
        quad encoder_FR(CLOCK_50, 1'b0, quadA_FR, quadB_FR, count_FR);
        quad encoder_RR(CLOCK_50, 1'b0, quadA_RR, quadB_RR, count_RR);

        logic [31:0] speed_FL, speed_RL, speed_FR, speed_RR;
        speed speed_counter_FL(PLL_CLOCK, count_FL, speed_FL);
        speed speed_counter_RL(PLL_CLOCK, count_RL, speed_RL);
        speed speed_counter_FR(PLL_CLOCK, count_FR, speed_FR);
        speed speed_counter_RR(PLL_CLOCK, count_RR, speed_RR);

        // Data from RPi
        logic   [31:0]  data_out;

        // SPI
        logic                   spi_clk, spi_cs, spi_mosi, spi_miso;
        logic   [31:0]  data_write, data_read;
        logic   [3:0]   data_addr;
        spi_slave spi_slave_instance(CLOCK_50, spi_clk, spi_cs, spi_mosi, spi_miso, 
                                                                // DATA TO SEND TO RPi :
                                                                speed_FL, speed_RL, speed_FR, speed_RR,
                                                                // DATA TO RECEIVE FROM RPi :
                                                                data_out);

        assign spi_clk                  = PI[11];   // SCLK = pin 16 = RPi_11
        assign spi_cs                   = PI[9];    // CE0  = pin 14 = RPi_9
        assign spi_mosi         = PI[15];   // MOSI = pin 20 = RPi_15
        assign PI[13]                       = spi_miso;     // MISO = pin 18 = RPi_13 

        assign LED = speed_FR[10:3];


endmodule
